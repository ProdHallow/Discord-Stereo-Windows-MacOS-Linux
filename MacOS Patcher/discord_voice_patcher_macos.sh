#!/usr/bin/env bash
###############################################################################
# Discord Voice Quality Patcher — macOS
# 48kHz | 512kbps | Stereo | Configurable Gain
# Made by: Oracle | Shaun | Hallow | Ascend | Sentry | Sikimzo | Cypher
###############################################################################
set -euo pipefail

SCRIPT_VERSION="6.0"
AUDIO_GAIN=1
SKIP_BACKUP=false
RESTORE_MODE=false

# ─── Colors ───────────────────────────────────────────────────────────────────
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; CYAN='\033[0;36m'
WHITE='\033[1;37m'; DIM='\033[0;90m'; BOLD='\033[1m'; NC='\033[0m'

# ─── Config ───────────────────────────────────────────────────────────────────
SAMPLE_RATE=48000
BITRATE=512
CACHE_DIR="$HOME/Library/Caches/DiscordVoicePatcher"
BACKUP_DIR="$CACHE_DIR/Backups"
LOG_FILE="$CACHE_DIR/patcher.log"
TEMP_DIR="$CACHE_DIR/build"

# macOS/Clang offsets — Auto-generated by discord_voice_node_offset_finder.py v5.0
# Build: MACHO binary | Size: 51065824 | MD5: f1295ce2f14beb330e77163d4d41be53
# Using file_offset values for direct binary patching
declare -A OFFSETS=(
    [CreateAudioFrameStereo]=0xA1E34A
    [AudioEncoderOpusConfigSetChannels]=0x41BE45
    [MonoDownmixer]=0x9E9DEB
    [EmulateStereoSuccess1]=0xA296FF
    [EmulateStereoSuccess2]=0xA29700
    [EmulateBitrateModified]=0xA29B5E
    [SetsBitrateBitrateValue]=0x6091E0
    [SetsBitrateBitwiseOr]=0x6091E8
    [Emulate48Khz]=0xA29867
    [HighPassFilter]=0x2B6EC0
    [HighpassCutoffFilter]=0x403A90
    [DcReject]=0x403C20
    [DownmixFunc]=0x3FAE70
    [AudioEncoderOpusConfigIsOk]=0x41C150
    [ThrowError]=0x945240
    [DuplicateEmulateBitrateModified]=0xA2EA44
    [EncoderConfigInit1]=0x41BE4F
    [EncoderConfigInit2]=0x41B9C8
)
FILE_OFFSET_ADJUSTMENT=0

# ─── Logging ──────────────────────────────────────────────────────────────────
log_info()    { echo -e "${WHITE}[--]${NC} $1"; echo "[INFO] $1" >> "$LOG_FILE" 2>/dev/null; }
log_ok()      { echo -e "${GREEN}[OK]${NC} $1"; echo "[OK] $1" >> "$LOG_FILE" 2>/dev/null; }
log_warn()    { echo -e "${YELLOW}[!!]${NC} $1"; echo "[WARN] $1" >> "$LOG_FILE" 2>/dev/null; }
log_error()   { echo -e "${RED}[XX]${NC} $1"; echo "[ERROR] $1" >> "$LOG_FILE" 2>/dev/null; }

# macOS-safe file size formatting
format_size() {
    local bytes="$1"
    if (( bytes > 1073741824 )); then
        printf "%.2f GB" "$(echo "scale=2; $bytes / 1073741824" | bc)"
    elif (( bytes > 1048576 )); then
        printf "%.2f MB" "$(echo "scale=2; $bytes / 1048576" | bc)"
    elif (( bytes > 1024 )); then
        printf "%.1f KB" "$(echo "scale=1; $bytes / 1024" | bc)"
    else
        echo "${bytes} bytes"
    fi
}

# macOS stat wrapper (different from GNU stat)
get_file_size() { stat -f%z "$1" 2>/dev/null || echo "0"; }
get_file_date() { stat -f"%Sm" -t"%Y-%m-%d %H:%M:%S" "$1" 2>/dev/null || echo "unknown"; }

banner() {
    echo ""
    echo -e "${CYAN}===== Discord Voice Quality Patcher v${SCRIPT_VERSION} =====${NC}"
    echo -e "${CYAN}      48kHz | 512kbps | Stereo | Gain Config${NC}"
    echo -e "${CYAN}      Platform: macOS | Multi-Client${NC}"
    echo -e "${CYAN}===============================================${NC}"
    echo ""
}

show_settings() {
    local color="$GREEN"
    if (( AUDIO_GAIN > 5 )); then color="$RED"
    elif (( AUDIO_GAIN > 2 )); then color="$YELLOW"; fi
    echo -e "Config: ${SAMPLE_RATE}Hz, ${BITRATE}kbps, Stereo, ${color}${AUDIO_GAIN}x gain${NC} (macOS)"
    echo ""
}

# ─── Parse Args ───────────────────────────────────────────────────────────────
usage() {
    echo "Usage: $0 [gain] [options]"
    echo ""
    echo "  gain            Audio gain multiplier (1-10, default: 1)"
    echo "  --skip-backup   Don't create backup before patching"
    echo "  --restore       Restore from backup"
    echo "  --list-backups  Show available backups"
    echo "  --help          Show this help"
    echo ""
    echo "Examples:"
    echo "  $0              # Patch with 1x gain (no boost)"
    echo "  $0 3            # Patch with 3x gain"
    echo "  $0 --restore    # Restore from backup"
    exit 0
}

for arg in "$@"; do
    case "$arg" in
        --skip-backup) SKIP_BACKUP=true ;;
        --restore) RESTORE_MODE=true ;;
        --list-backups) mkdir -p "$BACKUP_DIR"; ls -la "$BACKUP_DIR/" 2>/dev/null || echo "No backups found"; exit 0 ;;
        --help|-h) usage ;;
        [0-9]|[0-9][0-9]) AUDIO_GAIN="$arg" ;;
    esac
done

# Force base-10 interpretation (avoids octal issues with leading zeros like 08/09)
AUDIO_GAIN=$((10#$AUDIO_GAIN))

# Skip gain validation for modes that don't need it
if ! $RESTORE_MODE; then
    if (( AUDIO_GAIN < 1 || AUDIO_GAIN > 10 )); then
        echo "Error: gain must be 1-10"; exit 1
    fi
fi

# ─── Initialize ───────────────────────────────────────────────────────────────
mkdir -p "$CACHE_DIR" "$BACKUP_DIR" "$TEMP_DIR"
echo "=== Discord Voice Patcher Log ===" > "$LOG_FILE"
echo "Started: $(date)" >> "$LOG_FILE"
echo "Platform: macOS | Gain: ${AUDIO_GAIN}x" >> "$LOG_FILE"

# ─── Discord Client Detection ────────────────────────────────────────────────
declare -a CLIENT_NAMES=()
declare -a CLIENT_NODES=()

find_discord_clients() {
    log_info "Scanning for Discord installations..."

    local home="$HOME"
    local search_paths=(
        # User config directories (Electron auto-update)
        "$home/Library/Application Support/discord"
        "$home/Library/Application Support/discordcanary"
        "$home/Library/Application Support/discordptb"
        # Application bundles
        "/Applications/Discord.app/Contents/Resources"
        "/Applications/Discord Canary.app/Contents/Resources"
        "/Applications/Discord PTB.app/Contents/Resources"
        # Homebrew cask (less common)
        "/opt/homebrew/Caskroom/discord"
    )

    local names=(
        "Discord Stable"
        "Discord Canary"
        "Discord PTB"
        "Discord.app"
        "Discord Canary.app"
        "Discord PTB.app"
        "Discord (Homebrew)"
    )

    for i in "${!search_paths[@]}"; do
        local base="${search_paths[$i]}"
        local name="${names[$i]}"

        if [[ ! -d "$base" ]]; then continue; fi

        # Find discord_voice.node files
        local found_nodes
        found_nodes=$(find "$base" -maxdepth 6 -name "discord_voice.node" -type f 2>/dev/null | head -5)

        if [[ -n "$found_nodes" ]]; then
            # Pick the most recent one
            local latest=""
            local latest_time=0
            while IFS= read -r f; do
                local ftime
                ftime=$(stat -f%m "$f" 2>/dev/null || echo "0")
                if (( ftime > latest_time )); then
                    latest_time=$ftime
                    latest="$f"
                fi
            done <<< "$found_nodes"

            if [[ -n "$latest" && -f "$latest" ]]; then
                CLIENT_NAMES+=("$name")
                CLIENT_NODES+=("$latest")
                local size
                size=$(get_file_size "$latest")
                log_ok "Found: $name"
                log_info "  Path: $latest"
                log_info "  Size: $(format_size "$size")"
            fi
        fi
    done

    if [[ ${#CLIENT_NAMES[@]} -eq 0 ]]; then
        log_error "No Discord installations found!"
        echo ""
        echo "Searched the following locations:"
        for p in "${search_paths[@]}"; do echo "  - $p"; done
        echo ""
        echo "Make sure Discord is installed from discord.com or via Homebrew."
        return 1
    fi

    log_ok "Found ${#CLIENT_NAMES[@]} client(s)"
    return 0
}

# ─── Process Management ──────────────────────────────────────────────────────
kill_discord() {
    log_info "Closing Discord processes..."
    local apps=("Discord" "Discord Canary" "Discord PTB")
    for app in "${apps[@]}"; do
        osascript -e "tell application \"$app\" to quit" 2>/dev/null || true
    done
    sleep 2
    # Force kill if still running
    pkill -f "Discord" 2>/dev/null || true
    pkill -f "discord" 2>/dev/null || true
    sleep 1
}

# ─── Backup Management ───────────────────────────────────────────────────────
backup_node() {
    local source="$1"
    local client_name="$2"

    if $SKIP_BACKUP; then
        log_warn "Skipping backup (--skip-backup)"
        return 0
    fi

    if [[ ! -f "$source" ]]; then
        log_error "Cannot backup: file not found: $source"
        return 1
    fi

    local sanitized
    sanitized=$(echo "$client_name" | tr ' ' '_' | tr -d '[].')
    local backup_path="$BACKUP_DIR/discord_voice.node.${sanitized}.$(date +%Y%m%d_%H%M%S).backup"

    cp "$source" "$backup_path"
    log_ok "Backup: $(basename "$backup_path")"

    # Prune old backups (keep 10)
    local count
    count=$(ls -1 "$BACKUP_DIR"/*.backup 2>/dev/null | wc -l | tr -d ' ')
    if (( count > 10 )); then
        ls -1t "$BACKUP_DIR"/*.backup | tail -n +11 | xargs rm -f
    fi
    return 0
}

restore_from_backup() {
    banner
    log_info "Available backups:"
    echo ""

    local backups=()
    while IFS= read -r f; do
        [[ -n "$f" ]] && backups+=("$f")
    done < <(ls -1t "$BACKUP_DIR"/*.backup 2>/dev/null)

    if [[ ${#backups[@]} -eq 0 ]]; then
        log_error "No backups found in $BACKUP_DIR"
        exit 1
    fi

    for i in "${!backups[@]}"; do
        local bk="${backups[$i]}"
        local bsize
        bsize=$(get_file_size "$bk")
        local bdate
        bdate=$(get_file_date "$bk")
        echo -e "  [$(( i + 1 ))] ${bdate} - $(format_size "$bsize") - $(basename "$bk")"
    done
    echo ""

    read -rp "Select backup (1-${#backups[@]}, Enter for most recent): " sel
    if [[ -z "$sel" ]]; then sel=1; fi
    if [[ ! "$sel" =~ ^[0-9]+$ ]] || (( sel < 1 || sel > ${#backups[@]} )); then
        log_error "Invalid selection"; exit 1
    fi
    local backup_file="${backups[$(( sel - 1 ))]}"

    find_discord_clients || exit 1
    echo ""
    for i in "${!CLIENT_NAMES[@]}"; do
        echo -e "  [$(( i + 1 ))] ${CLIENT_NAMES[$i]}"
    done
    echo ""
    read -rp "Restore to which client? (1-${#CLIENT_NAMES[@]}): " csel
    if [[ -z "$csel" ]]; then csel=1; fi
    if [[ ! "$csel" =~ ^[0-9]+$ ]] || (( csel < 1 || csel > ${#CLIENT_NAMES[@]} )); then
        log_error "Invalid client selection"; exit 1
    fi
    local target="${CLIENT_NODES[$(( csel - 1 ))]}"

    read -rp "Replace $target with backup? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        log_warn "Cancelled"; exit 0
    fi

    kill_discord
    cp "$backup_file" "$target"
    log_ok "Restored! Restart Discord."
    exit 0
}

# ─── Compiler Detection ──────────────────────────────────────────────────────
COMPILER=""
COMPILER_TYPE=""

find_compiler() {
    log_info "Searching for C++ compiler..."

    # macOS: prefer Xcode's clang++ (available via Command Line Tools)
    if command -v clang++ &>/dev/null; then
        COMPILER="clang++"
        COMPILER_TYPE="Clang"
        log_ok "Found clang++ ($(clang++ --version 2>&1 | head -1))"
        return 0
    elif command -v c++ &>/dev/null; then
        COMPILER="c++"
        COMPILER_TYPE="Clang"
        log_ok "Found c++ (Xcode)"
        return 0
    elif command -v g++ &>/dev/null; then
        COMPILER="g++"
        COMPILER_TYPE="GCC"
        log_ok "Found g++ ($(g++ --version | head -1))"
        return 0
    fi

    log_error "No C++ compiler found!"
    echo ""
    echo "Install Xcode Command Line Tools:"
    echo "  xcode-select --install"
    echo ""
    echo "Or install via Homebrew:"
    echo "  brew install gcc"
    return 1
}

# ─── Source Code Generation ───────────────────────────────────────────────────
generate_amplifier_source() {
    local multiplier=$(( AUDIO_GAIN - 2 ))
    cat > "$TEMP_DIR/amplifier.cpp" << AMPEOF
#define Multiplier $multiplier

#include <cstdint>

extern "C" void hp_cutoff(const float* in, int cutoff_Hz, float* out, int* hp_mem, int len, int channels, int Fs, int arch)
{
    int* st = (hp_mem - 3553);
    *(int*)(st + 3557) = 1002;
    *(int*)((char*)st + 160) = -1;
    *(int*)((char*)st + 164) = -1;
    *(int*)((char*)st + 184) = 0;
    for (unsigned long i = 0; i < (unsigned long)(channels * len); i++) out[i] = in[i] * (channels + Multiplier);
}

extern "C" void dc_reject(const float* in, float* out, int* hp_mem, int len, int channels, int Fs)
{
    int* st = (hp_mem - 3553);
    *(int*)(st + 3557) = 1002;
    *(int*)((char*)st + 160) = -1;
    *(int*)((char*)st + 164) = -1;
    *(int*)((char*)st + 184) = 0;
    for (int i = 0; i < channels * len; i++) out[i] = in[i] * (channels + Multiplier);
}
AMPEOF
}

generate_patcher_source() {
    cat > "$TEMP_DIR/patcher.cpp" << 'PATCHEOF'
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <string>
#include <cstdlib>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>

#define SAMPLE_RATE SAMPLERATE_VAL
#define BITRATE BITRATE_VAL
#define AUDIO_GAIN AUDIOGAIN_VAL

extern "C" void dc_reject(const float*, float*, int*, int, int, int);
extern "C" void hp_cutoff(const float*, int, float*, int*, int, int, int, int);

namespace Offsets {
    constexpr uint32_t CreateAudioFrameStereo            = OFFSET_CreateAudioFrameStereo;
    constexpr uint32_t AudioEncoderOpusConfigSetChannels = OFFSET_AudioEncoderOpusConfigSetChannels;
    constexpr uint32_t MonoDownmixer                     = OFFSET_MonoDownmixer;
    constexpr uint32_t EmulateStereoSuccess1             = OFFSET_EmulateStereoSuccess1;
    constexpr uint32_t EmulateStereoSuccess2             = OFFSET_EmulateStereoSuccess2;
    constexpr uint32_t EmulateBitrateModified            = OFFSET_EmulateBitrateModified;
    constexpr uint32_t SetsBitrateBitrateValue           = OFFSET_SetsBitrateBitrateValue;
    constexpr uint32_t SetsBitrateBitwiseOr              = OFFSET_SetsBitrateBitwiseOr;
    constexpr uint32_t Emulate48Khz                      = OFFSET_Emulate48Khz;
    constexpr uint32_t HighPassFilter                    = OFFSET_HighPassFilter;
    constexpr uint32_t HighpassCutoffFilter              = OFFSET_HighpassCutoffFilter;
    constexpr uint32_t DcReject                          = OFFSET_DcReject;
    constexpr uint32_t DownmixFunc                       = OFFSET_DownmixFunc;
    constexpr uint32_t AudioEncoderOpusConfigIsOk        = OFFSET_AudioEncoderOpusConfigIsOk;
    constexpr uint32_t ThrowError                        = OFFSET_ThrowError;
    constexpr uint32_t DuplicateEmulateBitrateModified   = OFFSET_DuplicateEmulateBitrateModified;
    constexpr uint32_t EncoderConfigInit1                = OFFSET_EncoderConfigInit1;
    constexpr uint32_t EncoderConfigInit2                = OFFSET_EncoderConfigInit2;
    constexpr uint32_t FILE_OFFSET_ADJUSTMENT            = OFFSET_FileAdjustment;
};

class DiscordPatcher {
private:
    std::string modulePath;

    bool ApplyPatches(void* fileData, long long fileSize) {
        printf("Applying patches...\n");

        auto PatchBytes = [&](uint32_t offset, const char* bytes, size_t len) -> bool {
            uint32_t fileOffset = offset - Offsets::FILE_OFFSET_ADJUSTMENT;
            if ((long long)(fileOffset + len) > fileSize) {
                printf("ERROR: Patch at 0x%X (len %zu) exceeds file size!\n", offset, len);
                return false;
            }
            memcpy((char*)fileData + fileOffset, bytes, len);
            return true;
        };

        printf("  [1/5] Enabling stereo audio...\n");
        // EmulateStereoSuccess1: set channel count to 2
        if (!PatchBytes(Offsets::EmulateStereoSuccess1, "\x02", 1)) return false;
        // EmulateStereoSuccess2: macOS Clang has je (0x74), patch to jmp (0xEB)
        if (!PatchBytes(Offsets::EmulateStereoSuccess2, "\xEB", 1)) return false;
        // CreateAudioFrameStereo: macOS uses r12 not r13 — mov r12,rax; nop
        if (!PatchBytes(Offsets::CreateAudioFrameStereo, "\x49\x89\xC4\x90", 4)) return false;
        // AudioEncoderOpusConfigSetChannels: set to stereo
        if (!PatchBytes(Offsets::AudioEncoderOpusConfigSetChannels, "\x02", 1)) return false;
        // MonoDownmixer: NOP sled + jump
        if (!PatchBytes(Offsets::MonoDownmixer, "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xE9", 13)) return false;

        printf("  [2/5] Setting bitrate to 512kbps...\n");
        if (!PatchBytes(Offsets::EmulateBitrateModified, "\x00\xD0\x07", 3)) return false;
        if (!PatchBytes(Offsets::SetsBitrateBitrateValue, "\x00\xD0\x07\x00\x00", 5)) return false;
        if (!PatchBytes(Offsets::SetsBitrateBitwiseOr, "\x90\x90\x90", 3)) return false;
        if (!PatchBytes(Offsets::DuplicateEmulateBitrateModified, "\x00\xD0\x07", 3)) return false;

        printf("  [3/5] Enabling 48kHz sample rate...\n");
        if (!PatchBytes(Offsets::Emulate48Khz, "\x90\x90\x90", 3)) return false;

        printf("  [4/5] Injecting audio processing (%dx gain)...\n", AUDIO_GAIN);
        // HighPassFilter: just ret — Mach-O PIE, no fixed image base
        if (!PatchBytes(Offsets::HighPassFilter, "\xC3", 1)) return false;
        // Inject compiled hp_cutoff and dc_reject function bodies
        if (!PatchBytes(Offsets::HighpassCutoffFilter, (const char*)hp_cutoff, 0x100)) return false;
        if (!PatchBytes(Offsets::DcReject, (const char*)dc_reject, 0x1B6)) return false;
        // DownmixFunc: ret (was push rbp = 0x55 on macOS)
        if (!PatchBytes(Offsets::DownmixFunc, "\xC3", 1)) return false;
        // AudioEncoderOpusConfigIsOk: just ret (Clang prologue starts with push rbp)
        if (!PatchBytes(Offsets::AudioEncoderOpusConfigIsOk, "\xC3", 1)) return false;
        // ThrowError: ret (was push rbp = 0x55)
        if (!PatchBytes(Offsets::ThrowError, "\xC3", 1)) return false;

        printf("  [5/5] Patching encoder config (512kbps at creation)...\n");
        if (!PatchBytes(Offsets::EncoderConfigInit1, "\x00\xD0\x07\x00", 4)) return false;
        if (!PatchBytes(Offsets::EncoderConfigInit2, "\x00\xD0\x07\x00", 4)) return false;

        printf("  All patches applied!\n");
        return true;
    }

public:
    DiscordPatcher(const std::string& path) : modulePath(path) {}

    bool PatchFile() {
        printf("\n================================================\n");
        printf("  Discord Voice Quality Patcher (macOS)\n");
        printf("================================================\n");
        printf("  Target:  %s\n", modulePath.c_str());
        printf("  Config:  %dkHz, %dkbps, Stereo, %dx gain\n", SAMPLE_RATE/1000, BITRATE, AUDIO_GAIN);
        printf("================================================\n\n");

        printf("Opening file for patching...\n");
        int fd = open(modulePath.c_str(), O_RDWR);
        if (fd < 0) {
            printf("ERROR: Cannot open file: %s\n", modulePath.c_str());
            printf("Check permissions. You may need: chmod +w <file>\n");
            printf("Or if SIP is blocking: csrutil status\n");
            return false;
        }

        struct stat st;
        if (fstat(fd, &st) < 0) {
            printf("ERROR: Cannot stat file\n");
            close(fd);
            return false;
        }
        long long fileSize = st.st_size;
        printf("File size: %.2f MB\n", fileSize / (1024.0 * 1024.0));

        void* fileData = mmap(NULL, fileSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        if (fileData == MAP_FAILED) {
            printf("ERROR: Cannot mmap file\n");
            printf("This may be caused by macOS code signing. Try:\n");
            printf("  codesign --remove-signature '%s'\n", modulePath.c_str());
            close(fd);
            return false;
        }

        if (!ApplyPatches(fileData, fileSize)) {
            munmap(fileData, fileSize);
            close(fd);
            return false;
        }

        printf("\nSyncing patched file to disk...\n");
        msync(fileData, fileSize, MS_SYNC);
        munmap(fileData, fileSize);
        close(fd);

        // Remove code signature (patched binary will have invalid signature)
        printf("Removing code signature from patched binary...\n");
        // Use codesign to re-sign ad-hoc (allows execution without valid signature)
        if (system(("codesign --force --sign - '" + modulePath + "' 2>/dev/null").c_str()) != 0) {
            printf("Note: Could not re-sign binary. If Discord fails to load,\n");
            printf("try: codesign --remove-signature '%s'\n", modulePath.c_str());
        }

        printf("\n================================================\n");
        printf("  SUCCESS! Patching Complete!\n");
        printf("  Audio: %dx gain | %dkHz | %dkbps | Stereo\n", AUDIO_GAIN, SAMPLE_RATE/1000, BITRATE);
        printf("================================================\n\n");
        return true;
    }
};

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s <path_to_discord_voice.node>\n", argv[0]);
        return 1;
    }
    DiscordPatcher patcher(argv[1]);
    return patcher.PatchFile() ? 0 : 1;
}
PATCHEOF

    # Substitute offset values — macOS sed needs '' for in-place
    sed -i '' "s/SAMPLERATE_VAL/$SAMPLE_RATE/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/BITRATE_VAL/$BITRATE/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/AUDIOGAIN_VAL/$AUDIO_GAIN/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_CreateAudioFrameStereo/${OFFSETS[CreateAudioFrameStereo]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_AudioEncoderOpusConfigSetChannels/${OFFSETS[AudioEncoderOpusConfigSetChannels]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_MonoDownmixer/${OFFSETS[MonoDownmixer]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_EmulateStereoSuccess1/${OFFSETS[EmulateStereoSuccess1]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_EmulateStereoSuccess2/${OFFSETS[EmulateStereoSuccess2]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_EmulateBitrateModified/${OFFSETS[EmulateBitrateModified]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_SetsBitrateBitrateValue/${OFFSETS[SetsBitrateBitrateValue]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_SetsBitrateBitwiseOr/${OFFSETS[SetsBitrateBitwiseOr]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_Emulate48Khz/${OFFSETS[Emulate48Khz]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_HighPassFilter/${OFFSETS[HighPassFilter]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_HighpassCutoffFilter/${OFFSETS[HighpassCutoffFilter]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_DcReject/${OFFSETS[DcReject]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_DownmixFunc/${OFFSETS[DownmixFunc]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_AudioEncoderOpusConfigIsOk/${OFFSETS[AudioEncoderOpusConfigIsOk]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_ThrowError/${OFFSETS[ThrowError]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_DuplicateEmulateBitrateModified/${OFFSETS[DuplicateEmulateBitrateModified]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_EncoderConfigInit1/${OFFSETS[EncoderConfigInit1]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_EncoderConfigInit2/${OFFSETS[EncoderConfigInit2]}/g" "$TEMP_DIR/patcher.cpp"
    sed -i '' "s/OFFSET_FileAdjustment/$FILE_OFFSET_ADJUSTMENT/g" "$TEMP_DIR/patcher.cpp"
}

# ─── Compilation ──────────────────────────────────────────────────────────────
compile_patcher() {
    # Keep stdout clean so command substitution only captures the exe path
    log_info "Compiling patcher with $COMPILER_TYPE..." >&2

    local exe="$TEMP_DIR/DiscordVoicePatcher"
    rm -f "$exe"

    # macOS: compile for x86_64 specifically (Discord uses x86_64 under Rosetta on ARM)
    local arch_flags=""
    if [[ "$(uname -m)" == "arm64" ]]; then
        # On Apple Silicon, Discord runs x86_64 via Rosetta
        # The patcher itself can be native ARM, but the injected code
        # (hp_cutoff, dc_reject) must be compiled for x86_64
        log_warn "Apple Silicon detected — compiling for x86_64 (Rosetta)" >&2
        arch_flags="-arch x86_64"
    fi

    if ! $COMPILER -O2 -std=c++17 $arch_flags \
        "$TEMP_DIR/patcher.cpp" \
        "$TEMP_DIR/amplifier.cpp" \
        -o "$exe" 2>"$TEMP_DIR/build.log"; then
        log_error "Compilation failed!" >&2
        echo "" >&2
        cat "$TEMP_DIR/build.log" >&2
        return 1
    fi

    chmod +x "$exe"
    log_ok "Compilation successful" >&2
    echo "$exe"
    return 0
}

# ─── Client Selection ────────────────────────────────────────────────────────
select_clients() {
    echo ""
    echo -e "${CYAN}  Installed Discord clients:${NC}"
    echo ""
    for i in "${!CLIENT_NAMES[@]}"; do
        echo -e "  [$(( i + 1 ))] ${WHITE}${CLIENT_NAMES[$i]}${NC}"
        echo -e "      ${DIM}${CLIENT_NODES[$i]}${NC}"
    done
    echo ""
    echo -e "  [${WHITE}A${NC}] Patch all clients"
    echo -e "  [${WHITE}C${NC}] Cancel"
    echo ""

    read -rp "  Choice: " choice

    case "${choice}" in
        [cC]) log_warn "Cancelled"; exit 0 ;;
        [aA]) return 255 ;;  # patch all
        [0-9]*)
            if [[ ! "$choice" =~ ^[0-9]+$ ]]; then
                log_error "Invalid selection"; exit 1
            fi
            if (( choice >= 1 && choice <= ${#CLIENT_NAMES[@]} )); then
                return $(( choice - 1 ))
            fi
            log_error "Invalid selection"; exit 1
            ;;
        *) return 255 ;;  # default: patch all
    esac
}

# ─── Patch a single client ────────────────────────────────────────────────────
patch_client() {
    local idx="$1"
    local name="${CLIENT_NAMES[$idx]}"
    local node_path="${CLIENT_NODES[$idx]}"

    echo ""
    log_info "=== Processing: $name ==="
    log_info "Node: $node_path"
    local fsize
    fsize=$(get_file_size "$node_path")
    log_info "Size: $(format_size "$fsize")"

    # Backup
    if ! backup_node "$node_path" "$name"; then
        if ! $SKIP_BACKUP; then
            log_error "Backup failed, aborting"
            return 1
        fi
    fi

    # Ensure writable
    if [[ ! -w "$node_path" ]]; then
        log_warn "File not writable, attempting chmod..."
        chmod +w "$node_path" 2>/dev/null || {
            log_error "Cannot make file writable. Try: sudo chmod +w '$node_path'"
            return 1
        }
    fi

    # Generate source
    log_info "Generating source files..."
    generate_amplifier_source
    generate_patcher_source
    log_ok "Source files generated"

    # Compile
    local exe
    exe=$(compile_patcher) || return 1

    # Run patcher
    log_info "Applying binary patches (${AUDIO_GAIN}x gain)..."
    if "$exe" "$node_path"; then
        log_ok "Successfully patched $name!"
        return 0
    else
        log_error "Patcher failed for $name"
        return 1
    fi
}

# ─── Cleanup ──────────────────────────────────────────────────────────────────
cleanup() {
    rm -f "$TEMP_DIR/patcher.cpp" "$TEMP_DIR/amplifier.cpp" "$TEMP_DIR/DiscordVoicePatcher" "$TEMP_DIR/build.log" 2>/dev/null
}

# ─── Main ─────────────────────────────────────────────────────────────────────
main() {
    banner

    # Handle restore mode
    if $RESTORE_MODE; then
        restore_from_backup
        exit 0
    fi

    show_settings

    # Find Discord
    find_discord_clients || exit 1

    # Find compiler
    find_compiler || exit 1

    # Select clients. Capture non-zero returns (e.g. 255 = patch all)
    # without tripping set -e.
    local selection
    if select_clients; then
        selection=$?
    else
        selection=$?
    fi

    # Close Discord
    kill_discord

    local success=0
    local failed=0
    local total=0

    if (( selection == 255 )); then
        # Patch all
        total=${#CLIENT_NAMES[@]}
        for i in "${!CLIENT_NAMES[@]}"; do
            if patch_client "$i"; then
                success=$(( success + 1 ))
            else
                failed=$(( failed + 1 ))
            fi
        done
    else
        total=1
        if patch_client "$selection"; then
            success=1
        else
            failed=1
        fi
    fi

    cleanup

    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════${NC}"
    if (( failed == 0 )); then
        echo -e "${GREEN}  ✓ PATCHING COMPLETE: $success/$total successful${NC}"
    else
        echo -e "${YELLOW}  PATCHING: $success/$total successful, $failed failed${NC}"
    fi
    echo -e "${CYAN}═══════════════════════════════════════════════${NC}"
    echo ""
    echo "Restart Discord to apply changes."
    echo ""
    echo -e "${DIM}Note: If Discord shows 'damaged' on launch, run:${NC}"
    echo -e "${DIM}  xattr -cr /Applications/Discord.app${NC}"
}

trap cleanup EXIT
main "$@"
